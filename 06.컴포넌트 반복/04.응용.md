# 응용
지금까지 배운 개념을 응용하여 고정된 배열을 렌더링하는 것이 아닌, 동적인 배열을 렌더링하는 것을 구현해보자.  
그리고 index 값을 key로 사용하면 리렌더링이 비효율적이라고 배웠는데, 이러한 상황에 어떻게 고윳값을 만들 수 있는지도 살펴보자.  

__유동적인 데이터렌터링 실습 순서__
- 초기 상태 설정하기
- 데이터 추가 기능 구현하기
- 데이터 제거 기능 구현하기

## 초기 상태 설정하기
앞서 마든 컴포넌트에서 useState를 사용하여 상태를 설정해보자.  
세가지 상태를 사용할 텐데 하나는 데이터 배열이고, 다른 하나는 텍스트를 입력할 수 있는 input의 상태이다.  
그럼 마지막 하나는 무엇일까? 바로 데이터 배열에서 새로운 항목을 추가할 때 사용할 고유 id를 위한 상태이다.
```
import React, { useState } from "react";

const IterationSample = () => {
  const [names, setNames] = useState([
    {id:1, text: "눈사람"},
    {id:2, text: "얼음"},
    {id:3, text: "눈"},
    {id:4, text: "바람"}
  ]);
  const [inputText, setInputText] = useState("");
  const [nextId, setNextId] = useState(5); // 새로운 항목을 추가할 때 사용할 id
  const nameList = names.map((name, index) => <li key={name.id}>{name.text}</li>);

  return (
    <ul>{nameList}</ul>
  )
}

export default IterationSample

```

<br>
<br>

## 데이터 추가 기능 구현하기
새로운 이름을 등록할 수있는 기능을 구현해보자.  
우선 ul 태그의 상단에 input과 button을 렌더링하고, input의 상태를 관리해보자.
```
import React, { useState } from "react";

const IterationSample = () => {
  const [names, setNames] = useState([
    {id:1, text: "눈사람"},
    {id:2, text: "얼음"},
    {id:3, text: "눈"},
    {id:4, text: "바람"}
  ]);
  const [inputText, setInputText] = useState("");
  const [nextId, setNextId] = useState(5); // 새로운 항목을 추가할 때 사용할 id

  const onChange = e => setInputText(e.target.value);

  const nameList = names.map((name, index) => <li key={name.id}>{name.text}</li>);

  return (
    <>
      <input type="text" value={inputText} onChange={onChange }/>
      <button type="button">추가</button>
      <ul>{nameList}</ul>
    </>
  )
}

export default IterationSample
```
그 다음에는 버튼을 클릭했을 때 호출할 onClick 함수를 선언하여 버튼의 onClick 이벤트로 설정해보자.

onClick 함수에서는 배열의 내장 함수 concat을 사용하여 새로운 항목을 추가한 배열을 만들고, setNames를 통해 상태를 업데이트해 준다.
